<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Dungeons - Códigos do Jogo</title>
    <link rel="stylesheet" href="style.css">
    <link rel="shortcut icon" href="imagens/favicon.ico" type="image/x-icon">
</head>
<body>
    <nav>
        <a href="index.html" class="logo">Mini Dungeons</a>
        <ul class="nav-list">
            <li><a href="index.html">Sobre</a></li>
            <li><a href="tutorial.html">Tutorial</a></li> 
            <li><a href="codespace.html">Código</a></li>
            <li><a href="galeria.html">Galeria</a></li> 
            <li>
                <a href="https://github.com/FaellEmiliano/Projeto_Jogo" target="_blank">
                    <svg class="github-svg" viewBox="0 0 512 499.368" role="img" aria-hidden="false" focusable="false">
                        <path fill="currentColor" fill-rule="nonzero" d="M256.003 0C114.555 0 0 114.555 0 256.003c0 113.286 73.28 208.961 175.038 242.865 12.796 2.247 17.586-5.433 17.586-12.153 0-6.077-.309-26.225-.309-47.686-64.313 11.844-80.941-15.674-86.058-30.055-2.896-7.37-15.359-30.1-26.269-36.177-8.948-4.808-21.752-16.652-.31-16.961 20.168-.309 34.574 18.564 39.382 26.244 23.038 38.732 59.839 27.828 74.555 21.101 2.227-16.627 8.947-27.828 16.318-34.239-56.968-6.386-116.467-28.471-116.467-126.399 0-27.827 9.907-50.866 26.225-68.787-2.562-6.41-11.51-32.655 2.562-67.853 0 0 21.436-6.72 70.409 26.244 20.483-5.767 42.227-8.638 63.998-8.638 21.751 0 43.52 2.896 63.997 8.638 48.973-33.279 70.39-26.244 70.39-26.244 14.09 35.192 5.117 61.443 2.562 67.853 16.318 17.921 26.244 40.625 26.244 68.787 0 98.237-59.84 119.988-116.801 126.399 9.282 8.014 17.277 23.373 17.277 47.371 0 34.238-.309 61.751-.309 70.389 0 6.721 4.808 14.735 17.586 12.179C438.739 464.964 512 368.955 512 256.003 512 114.555 397.445 0 256.003 0z"/>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>

    <main>
        <h1 class="tutorial-title">Códigos</h1>
        <section class="code-section">
            <div class="codigo-content">
            <h2>Gerador de mapa</h2>
            <pre class="code-block">
                <code>
extends Node2D

#globais
@export var Dimensoes :Vector2i = Vector2i(5,5)
@export var Tamanho_Mínimo :int = 15
var Mapa :Array

#setar o array em branco
func inicializar_mapa():
    for x in Dimensoes.x:
        Mapa.append([])
        for y in Dimensoes.y:
            Mapa[x].append(0)

#imprime o array no console
func imprimir_mapa():
    var mapa_escrito : String = ""
    for y in range(Dimensoes.y-1,-1,-1):
        for x in Dimensoes.x:
            if Mapa[x][y]:
                mapa_escrito += "[" + str(Mapa[x][y]) + "]"
            else:
                mapa_escrito += "[ ]"
        mapa_escrito += '\n'
    print(mapa_escrito)

#posiciona o inicio do mapa
func g_inicio() -> Vector2i:
    var inicio :Vector2i
    inicio.x = randi_range(0,Dimensoes.x - 1)
    inicio.y = randi_range(0,Dimensoes.y - 1)
    Mapa[inicio.x][inicio.y] = -1
    return inicio

#cria o caminho "principal"
func g_caminho(anterior :Vector2i, nivel :int):
    if (nivel == 0):                     #fim da recursividade
        return 1
    var atual :Vector2i = anterior
    var direcao :Vector2i
    match randi() % 4:                   #escolhe a direção da próxima sala
        0:
            direcao = Vector2i.UP
        1:
            direcao = Vector2i.DOWN
        2:
            direcao = Vector2i.LEFT
        3:
            direcao = Vector2i.RIGHT
    for i in 4:
        var proximo = atual + direcao
        if(Dimensoes.x > proximo.x and proximo.x >= 0 and Dimensoes.y > proximo.y and proximo.y>= 0 and not Mapa[proximo.x][proximo.y]):   #Vê se a sala é possível de existir no Array
            atual += direcao
            Mapa[atual.x][atual.y] = nivel
            if g_caminho(atual,nivel-1):  #recursividade
                return true                                                                     #sala conseguiu ser posicionada
            else:
                Mapa[atual.x][atual.y] = 0
                atual -= direcao
        direcao = Vector2i(direcao.y, -direcao.x)         #muda a direção em sentido horário
    return false                                                                                #retorna false se não é possível posicionar uma sala
    


func gerar():
    var sucesso = false
    while not sucesso:
        Mapa.clear()
        inicializar_mapa()
        sucesso = g_caminho(g_inicio(), Tamanho_Mínimo)
    imprimir_mapa()
    return Mapa


func _ready() -> void:
    Mapa = gerar()
                </code>
            </pre>
        </div>
        </section>

        <section class="code-section">
            <div class="codigo-content">
            <h2>Entrada / Saída da Sala</h2>
            <pre class="code-block">
                <code>
extends Node2D
var player_entrou :bool = false
var inimigos :int = 0
@onready var tilemap = $TSala
var vizinhos_instanciados :Array
var pesos_inimigos = [1,4,5]
var boss = load("res://cenas/zumbi_boss.tscn")

func _on_area_sala_body_exited(body: Node2D) -> void:
	if body.is_in_group("enemy"):                                    #inimigo morreu
		inimigos -= 1
		if inimigos <=0:
			abrir_portas(vizinhos_instanciados)
			player_entrou = 1                              #player já entrou na sala e pode sair

func fechar_portas(vizinhos:Array):
	for c in vizinhos:
		if c == "N":
			tilemap.set_cell(Vector2i(7,1),6,Vector2i(0,0),0)
		if c == "S":
			tilemap.set_cell(Vector2i(7,7),6,Vector2i(0,2),0)
		if c == "L":
			tilemap.set_cell(Vector2i(13,4),6,Vector2i(0,3),0)
		if c == "O":
			tilemap.set_cell(Vector2i(1,4),6,Vector2i(0,1),0)

func abrir_portas(vizinhos:Array):
	vizinhos_instanciados = vizinhos
	for c in vizinhos:
		if c == "N":
			tilemap.set_cell(Vector2i(7,1),5,Vector2i(0,0),0)
		if c == "S":
			tilemap.set_cell(Vector2i(7,7),5,Vector2i(0,2),0)
		if c == "L":
			tilemap.set_cell(Vector2i(13,4),5,Vector2i(0,3),0)
		if c == "O":
			tilemap.set_cell(Vector2i(1,4),5,Vector2i(0,1),0)

func _on_area_sala_body_entered(body: Node2D) -> void:
	eventos.player_entrou.emit(self)
	if body.is_in_group("character") and not player_entrou:               #player entrou e ainda não matou os inimigos      
		fechar_portas(vizinhos_instanciados)
		eventos.desenhar_mapa.emit(self)
		if self.name == "Sala_final":             #para a sala final
			var zumbi = boss.instantiate()
			zumbi.position = Vector2(480,286)
			add_child(zumbi)
			inimigos += 1
		
	
func _process(_delta: float) -> void:
	if player_entrou:
		abrir_portas(vizinhos_instanciados)
	

func _on_saida_body_entered(_body: Node2D) -> void:                                      #passa do nível 1 para o 2 (caso seja a sala final)
	if inimigos <= 0:
		get_tree().change_scene_to_file("res://cenas/Mundo2.tscn")
                </code>
            </pre>
        </div>
        </section>

                <section class="code-section">
            <div class="codigo-content">
            <h2>Spawn de Inimigos</h2>
            <pre class="code-block">
                <code>
extends Node2D
var inimigos := [0,0,0,0]
@onready var inimigo1 = load("res://cenas/zumbi.tscn")
@onready var inimigo2 = load("res://cenas/esqueleto.tscn")
@onready var sala = $".."
@onready var mundo = $"../../.."


func _on_area_sala_body_entered(body: Node2D) -> void:
	await get_tree().process_frame
	if body.is_in_group("character") and not sala.player_entrou:
		
		for c in range(get_child_count()):
			if inimigos[c] != 0:
				sala.inimigos +=1
				var inimigo_inst 
				if inimigos[c] == 1:
					inimigo_inst = inimigo1.instantiate()
				if inimigos[c] == 2:
					inimigo_inst = inimigo2.instantiate()
				var marcador = get_child(c)
				inimigo_inst.position = marcador.position
				normalizar_dificuldade(inimigo_inst)
				add_child(inimigo_inst)
		if inimigos == [0,0,0,0]:
			sala.player_entrou = 1
		print(inimigos)

func aleatorizar():
	var valores = [0, 1, 2]
	var pesos = sala.pesos_inimigos  
	var soma_total = 0
	for p in pesos:
		soma_total += p
	var r = randf() * soma_total  
	var acumulado = 0
	for i in range(valores.size()):
		acumulado += pesos[i]
		if r <= acumulado:
			return valores[i]

func normalizar_dificuldade(inimigo):
	if mundo.name != "root":
		inimigo.atualizar(mundo.multiplicador)
	

func _ready() -> void:
	print(mundo.name)
	for c in range(inimigos.size()):
		inimigos[c] = aleatorizar()                
                </code>
            </pre>
        </div>
        </section>

            <section class="code-section">
            <div class="codigo-content">
            <h2>Zumbi</h2>
            <pre class="code-block">
                <code>
extends CharacterBody2D

var body_in_range: bool = false
var _is_dead: bool = false
var _player_ref = null
var state: String = "idle"

@export_category("object")
@export var vida :int = 1000
@export var dano :int = 10
@onready var state_machine = $AnimatedSprite2D

func _on_detection_area_body_entered(_body) -> void:
	if _body.is_in_group("character"):
		_player_ref = _body

func _on_detection_area_body_exited(_body) -> void:
	if _body.is_in_group("character"):
		_player_ref = null

func _physics_process(_delta: float) -> void:
	if _is_dead:
		return
	_animate()
	if _player_ref != null:
		if _player_ref.is_dead:
			velocity = Vector2.ZERO
			move_and_slide()
			return
		var _direction: Vector2 = global_position.direction_to(_player_ref.global_position)
		var _distance: float = global_position.distance_to(_player_ref.global_position)
		velocity = _direction * 150
		move_and_slide()

func _animate() -> void:
	if velocity == Vector2.ZERO:
		state = "idle"
	if velocity != Vector2.ZERO:
		if abs(velocity.x) > abs(velocity.y):
			state = "walk.x"
			if velocity.x > 0:
				state_machine.flip_h = false
			elif velocity.x < 0:
				state_machine.flip_h = true
		else:
			if velocity.y > 0:
				state = "walk.down"
			elif velocity.y < 0:
					state = "walk.up"
	state_machine.play(state)

func morte() -> void:
	_is_dead = true
	state_machine.play("death")
	queue_free()

func _on_animation_player_animation_finished(_anim_name: StringName) -> void:
	queue_free()

func tomar_dano(Dano:int)-> void:
	vida -= Dano
	if vida <= 0:
		morte()

func _on_hitbox_body_entered(body: Node2D) -> void:
	if body.is_in_group("character") and not _is_dead:
		body_in_range = true
		_attack_loop(body)


func atualizar(multi):
	dano = dano * multi
	vida = vida * multi



func _on_hitbox_body_exited(body: Node2D) -> void:
	if body.is_in_group("character"):
		body_in_range = false

func _attack_loop(body: Node2D) -> void:
	while body_in_range and not _is_dead:
		if body.is_in_group("character") and not body.is_dead:
			body.tomar_dano(dano)
		await get_tree().create_timer(1).timeout
                </code>
            </pre>
        </div>
        </section>

        <section class="code-section">
            <div class="codigo-content">
            <h2>Botão do Menu</h2>
            <pre class="code-block">
                <code>
extends CanvasLayer

@onready var resume_button = $VBoxContainer/resume

func _ready():
	visible = false

func _unhandled_input(event):
	if event.is_action_pressed("ui_cancel"):
		visible = true
		get_tree().paused = true 
		resume_button.grab_focus()

func _on_quit_pressed() -> void:
	get_tree().quit()

func _on_resume_pressed() -> void:
	get_tree().paused = false
	visible = false
                </code>
            </pre>
        </div>
        </section>

        <section class="code-section">
            <div class="codigo-content">
            <h2>Menu</h2>
            <pre class="code-block">
                <code>
extends CanvasLayer

@onready var resume_button = $VBoxContainer/resume

func _ready():
	visible = false

func _unhandled_input(event):
	if event.is_action_pressed("ui_cancel"):
		visible = true
		get_tree().paused = true 
		resume_button.grab_focus()

func _on_quit_pressed() -> void:
	get_tree().quit()

func _on_resume_pressed() -> void:
	get_tree().paused = false
	visible = false
                </code>
            </pre>
        </div>
        </section>

        
        <button id="tema">
            <svg id="moon-icon" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z">
            </svg>
    
            <svg id="sun-icon" viewBox="0 0 240 240" fill="currentColor" aria-hidden="true">
                <path d="M58.57,25.81c-2.13-3.67-0.87-8.38,2.8-10.51c3.67-2.13,8.38-0.88,10.51,2.8l9.88,17.1c2.13,3.67,0.87,8.38-2.8,10.51 c-3.67,2.13-8.38,0.88-10.51-2.8L58.57,25.81L58.57,25.81z M120,51.17c19.01,0,36.21,7.7,48.67,20.16 C181.12,83.79,188.83,101,188.83,120c0,19.01-7.7,36.21-20.16,48.67c-12.46,12.46-29.66,20.16-48.67,20.16 c-19.01,0-36.21-7.7-48.67-20.16C58.88,156.21,51.17,139.01,51.17,120c0-19.01,7.7-36.21,20.16-48.67 C83.79,58.88,101,51.17,120,51.17L120,51.17z M158.27,81.73c-9.79-9.79-23.32-15.85-38.27-15.85c-14.95,0-28.48,6.06-38.27,15.85 c-9.79,9.79-15.85,23.32-15.85,38.27c0,14.95,6.06,28.48,15.85,38.27c9.79,9.79,23.32,15.85,38.27,15.85 c14.95,0,28.48-6.06,38.27-15.85c9.79-9.79,15.85-23.32,15.85-38.27C174.12,105.05,168.06,91.52,158.27,81.73L158.27,81.73z M113.88,7.71c0-4.26,3.45-7.71,7.71-7.71c4.26,0,7.71,3.45,7.71,7.71v19.75c0,4.26-3.45,7.71-7.71,7.71 c-4.26,0-7.71-3.45-7.71-7.71V7.71L113.88,7.71z M170.87,19.72c2.11-3.67,6.8-4.94,10.48-2.83c3.67,2.11,4.94,6.8,2.83,10.48 l-9.88,17.1c-2.11,3.67-6.8,4.94-10.48,2.83c-3.67-2.11-4.94-6.8-2.83-10.48L170.87,19.72L170.87,19.72z M214.19,58.57 c3.67-2.13,8.38-0.87,10.51,2.8c2.13,3.67,0.88,8.38-2.8,10.51l-17.1,9.88c-3.67,2.13-8.38,0.87-10.51-2.8 c-2.13-3.67-0.88-8.38,2.8-10.51L214.19,58.57L214.19,58.57z M232.29,113.88c4.26,0,7.71,3.45,7.71,7.71 c0,4.26-3.45,7.71-7.71,7.71h-19.75c-4.26,0-7.71-3.45-7.71-7.71c0-4.26,3.45-7.71,7.71-7.71H232.29L232.29,113.88z M220.28,170.87 c3.67,2.11,4.94,6.8,2.83,10.48c-2.11,3.67-6.8,4.94-10.48,2.83l-17.1-9.88c-3.67-2.11-4.94-6.8-2.83-10.48 c2.11-3.67,6.8-4.94,10.48-2.83L220.28,170.87L220.28,170.87z M181.43,214.19c2.13,3.67,0.87,8.38-2.8,10.51 c-3.67,2.13-8.38,0.88-10.51-2.8l-9.88-17.1c-2.13-3.67-0.87-8.38,2.8-10.51c3.67-2.13,8.38-0.88,10.51,2.8L181.43,214.19 L181.43,214.19z M126.12,232.29c0,4.26-3.45,7.71-7.71,7.71c-4.26,0-7.71-3.45-7.71-7.71v-19.75c0-4.26,3.45-7.71,7.71-7.71 c4.26,0,7.71,3.45,7.71,7.71V232.29L126.12,232.29z M69.13,220.28c-2.11,3.67-6.8,4.94-10.48,2.83c-3.67-2.11-4.94-6.8-2.83-10.48 l9.88-17.1c2.11-3.67,6.8-4.94,10.48-2.83c3.67,2.11,4.94,6.8,2.83,10.48L69.13,220.28L69.13,220.28z M25.81,181.43 c-3.67,2.13-8.38,0.87-10.51-2.8c-2.13-3.67-0.88-8.38,2.8-10.51l17.1-9.88c3.67-2.13,8.38-0.87,10.51,2.8 c2.13,3.67,0.88,8.38-2.8,10.51L25.81,181.43L25.81,181.43z M7.71,126.12c-4.26,0-7.71-3.45-7.71-7.71c0-4.26,3.45-7.71,7.71-7.71 h19.75c4.26,0,7.71,3.45,7.71,7.71c0,4.26-3.45,7.71-7.71,7.71H7.71L7.71,126.12z M19.72,69.13c-3.67-2.11-4.94-6.8-2.83-10.48 c2.11-3.67,6.8-4.94,10.48-2.83l17.1,9.88c3.67,2.11,4.94,6.8,2.83,10.48c-2.11,3.67-6.8,4.94-10.48,2.83L19.72,69.13L19.72,69.13z"/>
            </svg>
        </button>
    </main>
    <footer>
        <p>&#169 2025 Mini Dungeons. Todos os direitos reservados.</p>
    </footer>
    <script src="script.js"></script>
</body>
</html>